/**
 * Object Spawner Service
 * Loads workflow objects from database and spawns them on maps.
 * Objects call the object-action Edge Function (â†’ n8n) for all integrations.
 */

import { RpgMap, RpgEvent, EventData } from '@rpgjs/server'
import { createClient } from '@supabase/supabase-js'
import { EmailItem } from '../items/EmailItem'
import { TaggedEmailItem } from '../items/TaggedEmail'
import { SummaryItem } from '../items/Summary'
import { DraftEmailItem } from '../items/DraftEmail'
import {
  isRecording,
  appendStep,
  startRecording,
  cancelRecording,
  stopAndSave,
} from './workflowRecorder'
import { executeWorkflow, listWorkflows } from './workflowRunner'

const supabaseUrl = process.env.SUPABASE_URL
const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY
const supabase = supabaseUrl && supabaseKey
  ? createClient(supabaseUrl, supabaseKey)
  : null

// Maps item type strings (from Edge Function responses) to RPG-JS item classes.
// player.addItem / player.removeItem require a class reference, not a string.
const ITEM_CLASS_MAP: Record<string, any> = {
  'email': EmailItem,
  'tagged-email': TaggedEmailItem,
  'summary': SummaryItem,
  'draft-email': DraftEmailItem,
}

// Dynamically create event class for an object instance
function createObjectEventClass(templateId: string, templateName: string) {
  @EventData({
    name: templateId,
    hitbox: { width: 32, height: 16 }
  })
  class DynamicObjectEvent extends RpgEvent {
    onInit() {
      if (templateId === 'desk') {
        this.setGraphic('male')
      } else if (templateId === 'archivist') {
        this.setGraphic('female')
      } else if (templateId === 'butler') {
        this.setGraphic('male')
      } else {
        this.setGraphic('female')
      }
    }

    async onAction(player: any) {
      console.log(`[Object] Player ${player.id} interacting with ${templateId}`)

      if (templateId === 'desk') {
        return this.handleDeskInteraction(player)
      }
      if (templateId === 'archivist' || templateId === 'recorder') {
        return this.handleArchivistInteraction(player)
      }
      if (templateId === 'butler') {
        return this.handleButlerInteraction(player)
      }

      // Default: mailbox interaction
      return this.handleMailboxInteraction(player)
    }

    async handleDeskInteraction(player: any) {
      const choiceObj = await player.showChoices('The desk is covered in papers.', [
        { text: 'ðŸ“‹ Process Mail', value: 'process' },
        { text: 'ðŸ” Check Status', value: 'check' },
        { text: 'Leave', value: 'leave' }
      ], { talkWith: this })

      const choice = typeof choiceObj === 'string' ? choiceObj : choiceObj?.value

      if (choice === 'leave') return

      const action = choice === 'process' ? 'process_mail' : 'check_desk'

      try {
        await player.showText(
          choice === 'process' ? 'Organizing your letters...' : 'Checking the desk...',
          { talkWith: this }
        )

        const response = await fetch(
          `${process.env.SUPABASE_URL}/functions/v1/object-action`,
          {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${process.env.SUPABASE_ANON_KEY}`
            },
            body: JSON.stringify({
              object_type: 'desk',
              action: action,
              player_id: player.id
            })
          }
        )

        const result = await response.json()

        if (result.success) {
          // Remove consumed items from inventory
          if (result.inventory_delta?.remove?.length > 0) {
            for (const item of result.inventory_delta.remove) {
              const ItemClass = ITEM_CLASS_MAP[item.type]
              if (ItemClass) {
                player.removeItem(ItemClass, item.count)
              } else {
                console.warn(`[Desk] No item class found for type: ${item.type}`)
              }
            }
          }

          // Add any items returned
          if (result.inventory_delta?.add?.length > 0) {
            for (const item of result.inventory_delta.add) {
              const ItemClass = ITEM_CLASS_MAP[item.type]
              if (ItemClass) {
                player.addItem(ItemClass, item.count || 1)
              } else {
                console.warn(`[Desk] Unknown item type: ${item.type}`)
              }
            }
          }

          await player.showText(result.message, { talkWith: this })

          // Record step if player is recording a workflow
          if (isRecording(player.id)) {
            appendStep(player.id, {
              object_type: 'desk',
              action: action,
              params: {},
              expected_inputs: [],
              credentials_ref: 'google',
            })
          }
        } else {
          await player.showText(`âŒ ${result.error?.message || 'Could not process'}`, { talkWith: this })
        }
      } catch (error) {
        console.error('[Desk] Error:', error)
        await player.showText('âŒ The desk is cluttered.', { talkWith: this })
      }
    }

    async handleMailboxInteraction(player: any) {
      const choiceObj = await player.showChoices('What would you like to do?', [
        { text: 'ðŸ“¬ Get Mail', value: 'get' },
        { text: 'âœ‰ï¸ Send Mail', value: 'send' },
        { text: 'Leave', value: 'leave' }
      ], { talkWith: this })

      const choice = typeof choiceObj === 'string' ? choiceObj : choiceObj?.value
      console.log(`[Mailbox] Player chose: ${choice}`)

      if (choice === 'leave') return

      if (choice === 'send') {
        const to = await player.showTextInput('Who would you like to write to?', { talkWith: this })
        if (!to || to.trim() === '') {
          await player.showText('Never mind then.', { talkWith: this })
          return
        }

        const subject = await player.showTextInput('What is the letter about?', { talkWith: this })
        if (!subject || subject.trim() === '') {
          await player.showText('You decided not to send an empty letter.', { talkWith: this })
          return
        }

        const body = await player.showTextInput('Write your message:', { talkWith: this, multiline: true })
        if (!body || body.trim() === '') {
          await player.showText('You put the blank letter away.', { talkWith: this })
          return
        }

        const inputs = { to: to.trim(), subject: subject.trim(), body: body.trim() }

        try {
          const sendResponse = await fetch(
            `${process.env.SUPABASE_URL}/functions/v1/object-action`,
            {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${process.env.SUPABASE_ANON_KEY}`
              },
              body: JSON.stringify({
                object_type: templateId,
                action: 'send_email',
                player_id: player.id,
                inputs,
              })
            }
          )

          const sendResult = await sendResponse.json()

          if (sendResult.success) {
            await player.showText('âœ‰ï¸ Your letter has been sent!', { talkWith: this })

            if (isRecording(player.id)) {
              appendStep(player.id, {
                object_type: templateId,
                action: 'send_email',
                params: inputs,
                expected_inputs: [],
                credentials_ref: 'google',
              })
            }
          } else {
            await player.showText(`âŒ Could not send: ${sendResult.error?.message}`, { talkWith: this })
          }
        } catch (error) {
          await player.showText('âŒ The postal service is having trouble.', { talkWith: this })
        }
        return
      }

      if (choice === 'get') {
        console.log(`[Mailbox] Starting fetch_emails for player ${player.id}`)

        try {
          await player.showText('Checking your mailbox...', { talkWith: this })

          const response = await fetch(
            `${process.env.SUPABASE_URL}/functions/v1/object-action`,
            {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${process.env.SUPABASE_ANON_KEY}`
              },
              body: JSON.stringify({
                object_type: templateId,
                action: 'fetch_emails',
                player_id: player.id
              })
            }
          )

          const result = await response.json()
          console.log(`[Mailbox] API result: success=${result.success}`, result.error ? `error=${result.error.message}` : '')

          if (result.success) {
            let itemsAdded = 0

            if (result.inventory_delta?.add?.length > 0) {
              for (const item of result.inventory_delta.add) {
                const ItemClass = ITEM_CLASS_MAP[item.type]
                if (ItemClass) {
                  player.addItem(ItemClass, item.count || 1)
                  itemsAdded += item.count || 1
                } else {
                  console.warn(`[Mailbox] Unknown item type: ${item.type}`)
                }
              }
            }

            if (itemsAdded > 0) {
              await player.showText(`ðŸ“¬ You collected ${itemsAdded} letters.`, { talkWith: this })
            } else {
              await player.showText('No new mail today.', { talkWith: this })
            }

            // Record step if player is recording a workflow
            if (isRecording(player.id)) {
              appendStep(player.id, {
                object_type: templateId,
                action: 'fetch_emails',
                params: {},
                expected_inputs: [],
                credentials_ref: 'google',
              })
            }
          } else {
            await player.showText(`âŒ ${result.error?.message || 'Could not check mail'}`, { talkWith: this })
          }
        } catch (error) {
          console.error('[Mailbox] Error:', error)
          await player.showText('âŒ Mailbox is not responding', { talkWith: this })
        }
      }
    }

    async handleArchivistInteraction(player: any) {
      const recording = isRecording(player.id)

      if (recording) {
        const choiceObj = await player.showChoices('I am chronicling your workflow...', [
          { text: 'ðŸ“œ Save workflow', value: 'save' },
          { text: 'âŒ Cancel recording', value: 'cancel' },
          { text: 'Continue', value: 'continue' }
        ], { talkWith: this })
        const choice = typeof choiceObj === 'string' ? choiceObj : choiceObj?.value

        if (choice === 'save') {
          const name = await player.showTextInput('Name this workflow:', { talkWith: this })
          if (!name?.trim()) {
            await player.showText('Recording cancelled.', { talkWith: this })
            cancelRecording(player.id)
            return
          }
          const saved = await stopAndSave(player, name.trim())
          if (saved) {
            await player.showText(`Workflow "${saved.name}" has been chronicled!`, { talkWith: this })
          } else {
            await player.showText('Something went wrong saving the workflow.', { talkWith: this })
          }
        } else if (choice === 'cancel') {
          cancelRecording(player.id)
          await player.showText('Recording cancelled.', { talkWith: this })
        }
        // 'continue' â€” just close dialog, keep recording
      } else {
        const choiceObj = await player.showChoices('I chronicle the actions of adventurers.', [
          { text: 'ðŸ”´ Start recording', value: 'start' },
          { text: 'Leave', value: 'leave' }
        ], { talkWith: this })
        const choice = typeof choiceObj === 'string' ? choiceObj : choiceObj?.value

        if (choice === 'start') {
          startRecording(player)
          await player.showText('Recording started! Use objects to build your workflow, then return to me.', { talkWith: this })
        }
      }
    }

    async handleButlerInteraction(player: any) {
      const choiceObj = await player.showChoices('Good day! How may I assist you?', [
        { text: 'â–¶ Run a workflow', value: 'run' },
        { text: 'ðŸ“‹ View my workflows', value: 'list' },
        { text: 'â° Schedule a workflow', value: 'schedule' },
        { text: 'Leave', value: 'leave' }
      ], { talkWith: this })

      const choice = typeof choiceObj === 'string' ? choiceObj : choiceObj?.value
      if (choice === 'leave' || !choice) return

      if (choice === 'list' || choice === 'run' || choice === 'schedule') {
        const workflows = await listWorkflows(player.id)

        if (workflows.length === 0) {
          await player.showText('You have no saved workflows. Visit the Archivist to record one.', { talkWith: this })
          return
        }

        const wfChoice = await player.showChoices(
          choice === 'run'
            ? 'Which workflow shall I run?'
            : choice === 'schedule'
            ? 'Which workflow shall I schedule?'
            : 'Your workflows:',
          workflows.map((w: any) => ({ text: `${w.name} (${w.run_count || 0} runs)`, value: w.id })),
          { talkWith: this }
        )

        const wfId = typeof wfChoice === 'string' ? wfChoice : wfChoice?.value
        if (!wfId || choice === 'list') return

        if (choice === 'run') {
          await player.showText('Running your workflow...', { talkWith: this })
          const result = await executeWorkflow(wfId, player.id, 'npc')

          if (result.success) {
            await player.showText(`Workflow complete! ${result.stepsCompleted} steps executed.`, { talkWith: this })
          } else {
            await player.showText(`Something went wrong at step ${result.stepsCompleted + 1}: ${result.error}`, { talkWith: this })
          }
        }

        if (choice === 'schedule') {
          const intervalChoice = await player.showChoices('How often should I run it?', [
            { text: 'Every 30 minutes', value: '30' },
            { text: 'Every hour', value: '60' },
            { text: 'Daily (9am)', value: 'daily' }
          ], { talkWith: this })

          const interval = typeof intervalChoice === 'string' ? intervalChoice : intervalChoice?.value
          if (!interval || interval === 'leave') return

          if (!supabase) {
            await player.showText('Schedule service unavailable.', { talkWith: this })
            return
          }

          const wf = workflows.find((w: any) => w.id === wfId)
          const wfName = wf?.name || 'workflow'

          await supabase.from('workflow_schedules').insert({
            workflow_id: wfId,
            user_id: player.id,
            schedule_type: interval === 'daily' ? 'cron' : 'interval',
            cron_expression: interval === 'daily' ? '0 9 * * *' : null,
            interval_minutes: interval !== 'daily' ? parseInt(interval) : null,
            next_run_at: new Date(Date.now() + 60000).toISOString(), // first run in 1 min
            is_active: true,
            npc_id: 'butler',
          })

          await player.showText(`Scheduled! I will run "${wfName}" automatically.`, { talkWith: this })
        }
      }
    }
  }

  return DynamicObjectEvent
}

// Load and spawn objects for a map
export async function spawnMapObjects(map: RpgMap, mapId: string) {
  if (!supabase) {
    console.error('[ObjectSpawner] Supabase not initialized')
    return
  }

  try {
    const { data: objects, error } = await supabase
      .from('object_instances')
      .select(`
        id,
        position,
        template:object_templates!inner(id, name, is_enabled)
      `)
      .eq('map_id', mapId)
      .eq('is_enabled', true)
      .eq('template.is_enabled', true)

    if (error) {
      console.error('[ObjectSpawner] Error loading objects:', error)
      return
    }

    console.log(`[ObjectSpawner] Found ${objects?.length || 0} objects for map ${mapId}`)

    for (const obj of objects || []) {
      const template = obj.template as any

      const EventClass = createObjectEventClass(template.id, template.name)

      const event = await map.createDynamicEvent({
        x: obj.position.x,
        y: obj.position.y,
        event: EventClass
      })

      if (event) {
        console.log(`[ObjectSpawner] Spawned ${template.name} at (${obj.position.x}, ${obj.position.y})`)
      }
    }
  } catch (error) {
    console.error('[ObjectSpawner] Error:', error)
  }
}
